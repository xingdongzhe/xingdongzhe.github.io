{"singlePage": [], "startSite": "", "filingNum": "", "onePageListNum": 15, "commentLabelColor": "#006b75", "yearColorList": ["#bc4c00", "#0969da", "#1f883d", "#A333D0"], "i18n": "CN", "themeMode": "manual", "dayTheme": "light", "nightTheme": "dark", "urlMode": "pinyin", "script": "", "style": "", "bottomText": "", "showPostSource": 1, "iconList": {}, "UTC": 8, "rssSplit": "sentence", "title": "xingdongzhe's blog", "subTitle": "xingdongzhe's blog", "avatarUrl": "https://github.githubassets.com/favicons/favicon.svg", "GMEEK_VERSION": "last", "postListJson": {"P1": {"htmlDir": "docs/post/Docs Test.html", "labels": ["documentation"], "postTitle": "Docs Test", "postUrl": "post/Docs%20Test.html", "postSourceUrl": "https://github.com/xingdongzhe/xingdongzhe.github.io/issues/1", "commentNum": 0, "wordCount": 11, "description": "- Docs Test\u3002", "top": 0, "createdAt": 1711883770, "style": "", "script": "", "createdDate": "2024-03-31", "dateLabelColor": "#bc4c00"}, "P2": {"htmlDir": "docs/post/asyncio core code with simple implement.html", "labels": ["asyncio", "Python"], "postTitle": "asyncio core code with simple implement", "postUrl": "post/asyncio%20core%20code%20with%20simple%20implement.html", "postSourceUrl": "https://github.com/xingdongzhe/xingdongzhe.github.io/issues/2", "commentNum": 0, "wordCount": 10597, "description": "### asyncio \u7684\u91cd\u8981\u7ec4\u6210\u90e8\u5206\r\n\r\n- \u591a\u8def\u590d\u7528(select/poll/epoll)\r\n- \u56de\u8c03\u51fd\u6570\r\n- Eventloop(\u6838\u5fc3\u7ec4\u4ef6)\r\n- Future\r\n- Task\r\n- Handle(TimerHandle)\r\n\r\n### \u5f02\u6b65\u7f16\u7a0b\u6a21\u578b\r\n\r\n- \u4e8b\u4ef6\u5faa\u73af + \u56de\u8c03\r\n\r\n### Eventloop(\u4e8b\u4ef6\u5faa\u73af)\u662f\u4ec0\u4e48\r\n\r\n- \u4e00\u53e5\u8bdd: \u4e8b\u4ef6\u5faa\u73af\u5c31\u4e00\u4e2a\u5faa\u73af\uff0c\u4e00\u4e2a\u65e0\u9650\u5faa\u73af\r\n\r\n### Eventloop(\u4e8b\u4ef6\u5faa\u73af)\u7684\u4f5c\u7528\u662f\u4ec0\u4e48\r\n\r\n- \u4e8b\u4ef6\u5faa\u73af\u662f asyncio\u7684\u5fc3\u810f\uff0c\u8d1f\u8d23\u5904\u7406 IO \uff0c\u5b89\u6392\u534f\u7a0b\u548c\u56de\u8c03\u51fd\u6570\u7684\u6267\u884c\u8ba1\u5212\uff0c\u5373\u4fdd\u5b58\u4e0a\u4e0b\u6587\u3001\u5207\u6362\u8fd0\u884c\u534f\u7a0b\u3001\u6062\u590d\u4e0a\u4e0b\u6587\u3001\u91cd\u65b0\u8fd0\u884c\u534f\u7a0b\r\n\r\n- \u4e8b\u4ef6\u5faa\u73af\u6709\u4e09\u4e2a\u91cd\u8981\u7ec4\u6210\u90e8\u5206\r\n\r\n  - IO \u5904\u7406\u673a\u5236\uff0c\u591a\u8def\u590d\u7528\r\n  - \u4efb\u52a1\u961f\u5217\r\n  - \u5f85\u5b89\u6392\u961f\u5217\r\n\r\n  ```python\r\n  # base_event.py\r\n  class BaseEventLoop:\r\n    def __init__(self):\r\n      self._ready = deque() # List[Handle]\r\n      self._scheduled = []  # List[TimerHandl]\uff0c\u662f\u4e00\u4e2a\u6700\u5c0f\u4e8c\u53c9\u5806\r\n      self._selector = Selector()\r\n      \r\n    def run_until_complete(self, future):\r\n      pass\r\n    \r\n    def create_task(self, coro):\r\n      pass\r\n    \r\n    def _run_once(self):\r\n      pass\r\n    \r\n    def call_soon(self, callback, *args):\r\n      pass\r\n  ```\r\n\r\n  \r\n\r\n- asyncio \u4e2d\u7684\u534f\u7a0b\u662f\u5982\u4f55\u4e32\u8054\u8d77\u6765\u7684\r\n\r\n  `Task._step \u548c Task._wakeup`\r\n\r\n- \u57fa\u4e8e\u751f\u6210\u5668\u7684\u534f\u7a0b, `yield`\r\n\r\n  - \u53ef\u4ee5\u4fdd\u5b58\u81ea\u5df1\u7684\u4e0a\u4e0b\u6587\uff0c\u5982\u8fd0\u884c\u72b6\u6001\uff0c\u8fd0\u884c\u7684\u503c\r\n\r\n  - \u8ba9\u51fa\u63a7\u5236\u6743\r\n  - \u4ea7\u51fa\u4e00\u4e2a\u503c\r\n  - \u63a5\u6536\u4e00\u4e2a\u503c\r\n  - \u53ef\u4ee5\u591a\u6b21\u91cd\u65b0\u8fdb\u5165\u4ece\u4e0a\u6b21\u8ba9\u51fa\u63a7\u5236\u6743\u7684\u5730\u65b9\r\n\r\n- \u539f\u751f\u534f\u7a0b, `__await__`\u6216\u8005`__iter__`\r\n\r\n- async \u662f\u4e00\u4e2a\u5173\u952e\u5b57\uff0casync def \u5b9a\u4e49\u7684\u7c7b\u578b\u8fd8\u662f\u4e00\u4e2afunction\u7c7b\u578b\uff0c\u53ea\u6709\u5f53\u5b83\u88ab\u8c03\u7528\u65f6\u624d\u8fd4\u56de\u4e00\u4e2a\u534f\u7a0b\u5bf9\u8c61\r\n   `async def` \u8ddf`def`\u5b9a\u4e49\u7684\u65b9\u6cd5\u5728\u6ca1\u88ab\u8c03\u7528\u65f6\u6ca1\u6709\u4efb\u4f55\u533a\u522b\uff0c\u4e0d\u5fc5\u770b\u5f97\u5f88\u795e\u79d8\uff0c\u5b83\u4e5f\u53ef\u4ee5\u6709`return`\u8bed\u53e5\r\n\r\n- asyncio\u5e95\u5c42\u8fd0\u884c\u90fd\u662f\u666e\u901a\u51fd\u6570\uff0c\u6bcf\u8f6e\u5faa\u73af\u53ea\u4f1a\u6267\u884c\u5f53\u524d\u5faa\u73af\u7684\u5c31\u7eea\u961f\u5217\u4e2d\u7684\u4efb\u52a1(\u51fd\u6570)\r\n   \r\n- Async \u548c await \u53ea\u662f\u8bed\u6cd5\u7cd6\uff0c\u6e90\u7801\u5e95\u4e0b\u4e5f\u662f\u8fd8\u662f\u7528\u4e86\u751f\u6210\u5668, \u662f\u9047\u5230`yield`\u5173\u952e\u5b57\u624d\u4f1a\u6302\u8d77\r\n\r\n  ```python\r\n  def __iter__(self):\r\n    if not self.done():\r\n      self._asyncio_future_blocking = True\r\n      yield self  # This tells Task to wait for completion.\r\n      assert self.done(), \"yield from wasn't used with future\"\r\n      return self.result()  # May raise too.\r\n    \r\n  # PY35 = sys.version_info >= (3, 5)\r\n  if compat.PY35:\r\n  \t\t__await__ = __iter__ # make compatible with 'await' expression\r\n  ```\r\n\r\n  \r\n\r\n- \u751f\u6210\u5668\u7684\u65b9\u6cd5\r\n\r\n  - send\r\n  - throw\r\n  - close\r\n  - \\_\\_next\\_\\_(next)\r\n\r\n- \u751f\u6210\u5668\u5b8c\u7ed3\u5f02\u5e38:\r\n\r\n  `StopIteration`\r\n\r\n- Event_loop\r\n\r\n  ```python\r\n  # base_event.py\r\n  class BaseEventLoop:\r\n    def __init__(self):\r\n      self._ready = deque() # List[Handle]\r\n      self._scheduled = []  # List[TimerHandl]\uff0c\u662f\u4e00\u4e2a\u6700\u5c0f\u4e8c\u53c9\u5806\r\n      self._selector = Selector()\r\n      \r\n    def run_until_complete(self, future):\r\n      future = tasks.ensure_future(future, loop=self)\r\n      future.add_done_callback(_run_until_complete_cb)\r\n      self.run_forever()\r\n      \r\n      \r\n    def run_forever():\r\n      self._run_once()\r\n    \r\n    def create_task(self, coro):\r\n       task = tasks.Task(coro, loop=self)\r\n       return task\r\n    \r\n    def _run_once(self):\r\n      event_list = self._selector.select(timeout)\r\n      self._process_events(event_list)\r\n      ntodo = len(self._ready)\r\n      for i in range(ntodo):\r\n        handle = self._ready.popleft()\r\n        handle._run()\r\n    \r\n    def call_soon(self, callback, *args):\r\n      handle = events.Handle(callback, args, self)\r\n      self._ready.append(handle)\r\n      return handle\r\n    \r\n    def call_at(self, when, callback, *args):\r\n      timer = events.TimerHandle(when, callback, args, self)\r\n      heapq.heappush(self._scheduled, timer)\r\n      timer._scheduled = True\r\n      return timer\r\n  ```\r\n\r\n  \r\n\r\n- Future\r\n\r\n  ```python\r\n  # futures.py\r\n  class Future:\r\n    def __init__(self, loop=None):\r\n      self._loop = loop\r\n      self._callback = [] # List[Function]\r\n      \r\n    def set_result(self, result):\r\n       self._result = result\r\n       self._state = _FINISHED\r\n       for callback in self.callbacks:\r\n          self._loop.call_soon(callback, self)\r\n          \r\n    def __iter__(self):\r\n    \tif not self.done():\r\n      \tself._asyncio_future_blocking = True\r\n        yield self  # This tells Task to wait for completion.\r\n      assert self.done(), \"yield from wasn't used with future\"\r\n      return self.result()  # May raise too.\r\n  ```\r\n\r\n  \r\n\r\n- Task\r\n\r\n  ```python\r\n  # tasks.py\r\n  class Task(Future):\r\n    def __init__(self, coro, *, loop=None):\r\n      super().__init__(self, loop)\r\n      self._coro = coro\r\n      self._loop.call_soon(self._step)\r\n      \r\n  \tdef _step(self, exc=None):\r\n      coro = self._coro\r\n      try:\r\n      \tresult = coro.send(None)\r\n      except StopIteration as exc:\r\n        self.set_result(exc.value)\r\n      else:\r\n        result.add_done_callback(self._wakeup)\r\n      \r\n    \r\n    def _wakeup(self, future):\r\n      self._step()\r\n  ```\r\n\r\n- Handle\r\n\r\n  ```python\r\n  # events.py\r\n  class Handle:\r\n      def __init__(self, callback, args, loop):\r\n          self._loop = loop\r\n          self._callback = callback\r\n          self._args = args\r\n          \r\n  \t\tdef _run(self):\r\n        self._callback(*self._args)\r\n      \r\n      \r\n  class TimerHandle(Handle):\r\n      def __init__(self, when, callback, args, loop):\r\n          assert when is not None\r\n          super().__init__(callback, args, loop)\r\n          self._when = when\r\n          self._scheduled = False\r\n  ```\r\n\r\n  \r\n\r\n### \u4ee3\u7801\u6267\u884c\u6d41\u7a0b\r\n\r\n```python\r\nimport asyncio\r\n\r\n\r\nasync def cor():\r\n    print('enter cor ...')\r\n    await asyncio.sleep(2)\r\n    print('exit cor ...')\r\n    \r\n    return 'cor'\r\n\r\nloop = asyncio.get_event_loop()\r\ntask = loop.create_task(cor())\r\nrst = loop.run_until_complete(task)\r\nprint(rst)\r\n```\r\n\r\n```python\r\nclass Task(futures.Future):\r\n    \r\n    ...\r\n    \r\n    def _step(self, exc=None):\r\n        \"\"\"\r\n        _step\u65b9\u6cd5\u53ef\u4ee5\u770b\u505a\u662ftask\u5305\u88c5\u7684coroutine\u5bf9\u8c61\u4e2d\u7684\u4ee3\u7801\u7684\u76f4\u5230yield\u7684\u524d\u534a\u90e8\u5206\u903b\u8f91\r\n        \"\"\"\r\n        ...\r\n        try:\r\n            if exc is None:\r\n                \r\n                # 1.\u5173\u952e\u4ee3\u7801\r\n                result = coro.send(None)\r\n            else:\r\n                result = coro.throw(exc)\r\n        # 2. coro\u6267\u884c\u5b8c\u6bd5\u4f1a\u629b\u51faStopIteration\u5f02\u5e38\r\n        except StopIteration as exc:\r\n            if self._must_cancel:\r\n                # Task is cancelled right before coro stops.\r\n                self._must_cancel = False\r\n                self.set_exception(futures.CancelledError())\r\n            else:\r\n                # result\u4e3aNone\u65f6\uff0c\u8c03\u7528task\u7684callbasks\u5217\u8868\u4e2d\u7684\u56de\u8c03\u65b9\u6cd5\uff0c\u5728\u8c03\u7528loop.run_until_complite\uff0c\u7ed3\u675floop\u5faa\u73af\r\n                self.set_result(exc.value)\r\n        except futures.CancelledError:\r\n            super().cancel()  # I.e., Future.cancel(self).\r\n        except Exception as exc:\r\n            self.set_exception(exc)\r\n        except BaseException as exc:\r\n            self.set_exception(exc)\r\n            raise\r\n        # 3. result = coro.send(None)\u4e0d\u629b\u51fa\u5f02\u5e38\r\n        else:\r\n            # 4. \u67e5\u770bresult\u662f\u5426\u542b\u6709_asyncio_future_blocking\u5c5e\u6027\r\n            blocking = getattr(result, '_asyncio_future_blocking', None)\r\n            if blocking is not None:\r\n                # Yielded Future must come from Future.__iter__().\r\n                if result._loop is not self._loop:\r\n                    self._loop.call_soon(\r\n                        self._step,\r\n                        RuntimeError(\r\n                            'Task {!r} got Future {!r} attached to a '\r\n                            'different loop'.format(self, result)))\r\n                \r\n                elif blocking:\r\n                    if result is self:\r\n                        self._loop.call_soon(\r\n                            self._step,\r\n                            RuntimeError(\r\n                                'Task cannot await on itself: {!r}'.format(\r\n                                    self)))\r\n                    # 4.1. \u5982\u679cresult\u662f\u4e00\u4e2afuture\u5bf9\u8c61\u65f6\uff0cblocking\u4f1a\u88ab\u8bbe\u7f6e\u6210true\r\n                    else:\r\n                        result._asyncio_future_blocking = False\r\n                        # \u628a_wakeup\u56de\u8c03\u51fd\u6570\u8bbe\u7f6e\u5230\u6b64future\u5bf9\u8c61\u4e2d\uff0c\u5f53\u6b64future\u5bf9\u8c61\u8c03\u7528set_result()\u65b9\u6cd5\u65f6\uff0c\u5c31\u4f1a\u8c03\u7528_wakeup\u65b9\u6cd5\r\n                        result.add_done_callback(self._wakeup)\r\n                        self._fut_waiter = result\r\n                        if self._must_cancel:\r\n                            if self._fut_waiter.cancel():\r\n                                self._must_cancel = False\r\n                else:\r\n                    self._loop.call_soon(\r\n                        self._step,\r\n                        RuntimeError(\r\n                            'yield was used instead of yield from '\r\n                            'in task {!r} with {!r}'.format(self, result)))\r\n            # 5. \u5982\u679cresult\u662fNone\uff0c\u5219\u6ce8\u518ctask._step\u5230loop\u5bf9\u8c61\u4e2d\u53bb\uff0c\u5728\u4e0b\u4e00\u8f6e_run_once\u4e2d\u88ab\u56de\u8c03\r\n            elif result is None:\r\n                # Bare yield relinquishes control for one event loop iteration.\r\n                self._loop.call_soon(self._step)\r\n\r\n            # --------\u4e0b\u9762\u7684\u4ee3\u7801\u53ef\u4ee5\u6682\u65f6\u4e0d\u5173\u6ce8\u4e86--------\r\n            elif inspect.isgenerator(result):\r\n                # Yielding a generator is just wrong.\r\n                self._loop.call_soon(\r\n                    self._step,\r\n                    RuntimeError(\r\n                        'yield was used instead of yield from for '\r\n                        'generator in task {!r} with {}'.format(\r\n                            self, result)))\r\n            else:\r\n                # Yielding something else is an error.\r\n                self._loop.call_soon(\r\n                    self._step,\r\n                    RuntimeError(\r\n                        'Task got bad yield: {!r}'.format(result)))\r\n        finally:\r\n            self.__class__._current_tasks.pop(self._loop)\r\n            self = None  # Needed to break cycles when an exception occurs.\r\n\r\n    def _wakeup(self, future):\r\n        try:\r\n            future.result()\r\n        except Exception as exc:\r\n            # This may also be a cancellation.\r\n            self._step(exc)\r\n        else:\r\n            \r\n            # \u8fd9\u91cc\u662f\u5173\u952e\u4ee3\u7801\uff0c\u4e0a\u6b21\u7684_step()\u6267\u884c\u5230\u7b2c\u4e00\u6b21\u78b0\u5230yield\u7684\u5730\u65b9\u6302\u4f4f\u4e86\uff0c\u6b64\u65f6\u518d\u6b21\u6267\u884c_step(),\r\n            # \u4e5f\u5c31\u662f\u518d\u6b21\u6267\u884c result = coro.send(None) \u8fd9\u53e5\u4ee3\u7801\uff0c\u4e5f\u5c31\u662f\u4ece\u4e0a\u6b21yield\u7684\u5730\u65b9\u7ee7\u7eed\u6267\u884cyield\u540e\u9762\u7684\u903b\u8f91\r\n            self._step()\r\n        self = None  # Needed to break cycles when an exception occurs.\r\n```\r\n\r\n\r\n\r\n\r\n\r\n`run_until_complete()` --> `run_forever()` --> `_run_once()`\uff0c\u91cd\u70b9\u770b`_run_once`\u8fd9\u4e2a\u65b9\u6cd5\u7684\u6267\u884c\r\n\r\n\u6b64\u65f6:\r\n\r\n- `cor`\u534f\u7a0b\u8fd8\u672a\u5f00\u59cb\u6267\u884c\r\n- `loop._ready = [handle(task._step)]`\uff0c`loop._scheduled = [], task._callbacks=[_run_until_complete_cb]`\r\n\r\n#### \u7b2c\u4e00\u8f6e`_run_once()`\u7684\u8c03\u7528\u6267\u884c\u5f00\u59cb\r\n\r\n\u6b64\u65f6:\r\n\r\n- `cor`\u534f\u7a0b\u7684\u6267\u884c\u6d41\u7a0b\u6302\u8d77\u5728`sleep`\u534f\u7a0b\u7684\u4e2d\u4ea7\u751f\u7684\u65b0`Future`\u5bf9\u8c61\u7684`__iter__`\u65b9\u6cd5\u7684`yield`\u5904\r\n- \u65b0`Future`\u5bf9\u8c61\u7684`_callbacks = [task._wakeup,]`\r\n- `loop._scheduled=[handle(delay_2s__set_result_unless_cancelled)]`\uff0c`loop._ready=[]`\r\n\r\n#### \u7b2c\u4e8c\u8f6e`_run_once()`\u7684\u8c03\u7528\u6267\u884c\u5f00\u59cb\r\n\r\n\u6b64\u65f6:\r\n\r\n- `cor`\u534f\u7a0b\u7684\u6267\u884c\u6d41\u7a0b\u6302\u8d77\u5728`sleep`\u534f\u7a0b\u7684\u4e2d\u4ea7\u751f\u7684\u65b0`Future`\u5bf9\u8c61\u7684`__iter__`\u65b9\u6cd5\u7684`yield`\u5904\u3002", "top": 0, "createdAt": 1711883896, "style": "", "script": "", "createdDate": "2024-03-31", "dateLabelColor": "#bc4c00"}}, "singeListJson": {}, "labelColorDict": {"asyncio": "#92CE86", "bug": "#d73a4a", "documentation": "#0075ca", "duplicate": "#cfd3d7", "enhancement": "#a2eeef", "good first issue": "#7057ff", "help wanted": "#008672", "invalid": "#e4e669", "Python": "#155007", "question": "#d876e3", "wontfix": "#ffffff"}, "displayTitle": "xingdongzhe's blog", "faviconUrl": "https://github.githubassets.com/favicons/favicon.svg", "homeUrl": "https://xingdongzhe.github.io", "prevUrl": "disabled", "nextUrl": "disabled"}